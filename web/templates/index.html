<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="/static/index.css">
</head>
<body>
    <div class="layout">
        <aside class="sidebar left-sidebar">
            <h1>ğŸ“š {{ title }}</h1>
            <p class="sidebar-desc">ì‘ì—… íŒ¨ë„ (ìŠ¤ì¼ˆë ˆí†¤)</p>

            <section class="tool-box">
                <h2>ìºë¦­í„° ì‚¬ì „ ìƒì„±</h2>
                <label for="dict-provider">Provider</label>
                <select id="dict-provider"></select>
                <label for="dict-model">Model</label>
                <select id="dict-model"></select>
                <button type="button" id="dict-generate-btn" class="action-btn">ìºë¦­í„° ì‚¬ì „ ìƒì„±</button>
            </section>

            <section class="tool-box">
                <h2>ë²ˆì—­</h2>
                <label for="translate-provider">Provider</label>
                <select id="translate-provider"></select>
                <label for="translate-model">Model</label>
                <select id="translate-model"></select>
                <button type="button" id="translate-start-btn" class="action-btn">ë²ˆì—­ ì‹œì‘</button>
            </section>
        </aside>

        <main class="main-panel">
            <section class="json-viewer">
                <h2>character_dictionary.json ë‚´ìš© <span id="save-indicator" class="save-indicator"></span></h2>
                <div id="json-content">
                    <p class="json-message">ì˜¤ë¥¸ìª½ì—ì„œ íŒŒì¼ì„ ì„ íƒí•˜ë©´ character_dictionary.json ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                </div>
            </section>
            <section class="json-viewer">
                <h2>ì‘ì—… ì§„í–‰ë¥  / ë¡œê·¸</h2>
                <div id="task-progress">
                    <p class="json-message">ëŒ€ê¸° ì¤‘</p>
                </div>
                <pre id="task-logs" class="json-message" style="max-height: 220px; overflow: auto; white-space: pre-wrap;">ë¡œê·¸ ì—†ìŒ</pre>
            </section>
        </main>

        <aside class="sidebar right-sidebar">
            <section class="upload-container">
                <h2>íŒŒì¼ ì—…ë¡œë“œ ë° ì„ íƒ</h2>
                <p class="sidebar-desc">ë²ˆì—­í•  EPUB íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•´ ì—…ë¡œë“œí•˜ì„¸ìš”.</p>

                <div id="drop-zone">
                    <p>ğŸ“¥ ì—¬ê¸°ì— íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜, í´ë¦­í•´ì„œ ì„ íƒí•˜ì„¸ìš”</p>
                    <input type="file" id="file-input" accept=".epub">
                </div>

                <div id="result-msg"></div>

                <section class="uploaded-list">
                    <h3>ì—…ë¡œë“œëœ EPUB ëª©ë¡</h3>
                    {% set initial_files = uploaded_items if uploaded_items is defined else uploaded_files if uploaded_files is defined else [] %}
                    <ul id="uploaded-files">
                        {% if initial_files %}
                            {% for item in initial_files %}
                                {% set filename = item.filename if item is mapping else item %}
                                {% set has_dictionary = item.has_character_dictionary if item is mapping else true %}
                                <li>
                                    <span class="file-item" data-filename="{{ filename }}" data-has-dictionary="{{ 'true' if has_dictionary else 'false' }}">{{ filename }}</span>
                                </li>
                            {% endfor %}
                        {% else %}
                            <li class="empty">ì•„ì§ ì—…ë¡œë“œëœ EPUB íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</li>
                        {% endif %}
                    </ul>
                </section>
            </section>
        </aside>
    </div>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const resultMsg = document.getElementById('result-msg');
        const uploadedFiles = document.getElementById('uploaded-files');
        const jsonContent = document.getElementById('json-content');
        const saveIndicator = document.getElementById('save-indicator');
        const dictProviderSelect = document.getElementById('dict-provider');
        const dictModelSelect = document.getElementById('dict-model');
        const translateProviderSelect = document.getElementById('translate-provider');
        const translateModelSelect = document.getElementById('translate-model');
        const dictGenerateBtn = document.getElementById('dict-generate-btn');
        const translateStartBtn = document.getElementById('translate-start-btn');
        const taskProgress = document.getElementById('task-progress');
        const taskLogs = document.getElementById('task-logs');
        let selectedFilename = null;
        let activeTaskId = null;
        let taskPollTimer = null;
        let currentJsonData = null;
        let isDirty = false;
        let autoSaveTimer = null;
        const AUTO_SAVE_INTERVAL = 5000;
        const LS_PREFIX = 'erst-edit-';

        function setSelectOptions(selectElement, values, placeholder) {
            selectElement.innerHTML = '';

            if (!values || values.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = placeholder;
                selectElement.appendChild(option);
                return;
            }

            values.forEach((value) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                selectElement.appendChild(option);
            });
        }

        function loadModels(provider, modelSelect) {
            if (!provider) {
                setSelectOptions(modelSelect, [], 'ëª¨ë¸ ì—†ìŒ');
                return;
            }

            fetch(`/models?provider=${encodeURIComponent(provider)}`)
                .then((response) => response.json())
                .then((data) => {
                    if (data.status !== 'success') {
                        setSelectOptions(modelSelect, [], 'ëª¨ë¸ ì¡°íšŒ ì‹¤íŒ¨');
                        return;
                    }

                    setSelectOptions(modelSelect, data.models, 'ëª¨ë¸ ì—†ìŒ');
                })
                .catch(() => {
                    setSelectOptions(modelSelect, [], 'ëª¨ë¸ ì¡°íšŒ ì‹¤íŒ¨');
                });
        }

        function loadProviderAndModels() {
            fetch('/providers')
                .then((response) => response.json())
                .then((data) => {
                    if (data.status !== 'success') {
                        setSelectOptions(dictProviderSelect, [], 'Provider ì¡°íšŒ ì‹¤íŒ¨');
                        setSelectOptions(translateProviderSelect, [], 'Provider ì¡°íšŒ ì‹¤íŒ¨');
                        setSelectOptions(dictModelSelect, [], 'ëª¨ë¸ ì—†ìŒ');
                        setSelectOptions(translateModelSelect, [], 'ëª¨ë¸ ì—†ìŒ');
                        return;
                    }

                    setSelectOptions(dictProviderSelect, data.providers, 'Provider ì—†ìŒ');
                    setSelectOptions(translateProviderSelect, data.providers, 'Provider ì—†ìŒ');

                    loadModels(dictProviderSelect.value, dictModelSelect);
                    loadModels(translateProviderSelect.value, translateModelSelect);
                })
                .catch(() => {
                    setSelectOptions(dictProviderSelect, [], 'Provider ì¡°íšŒ ì‹¤íŒ¨');
                    setSelectOptions(translateProviderSelect, [], 'Provider ì¡°íšŒ ì‹¤íŒ¨');
                    setSelectOptions(dictModelSelect, [], 'ëª¨ë¸ ì—†ìŒ');
                    setSelectOptions(translateModelSelect, [], 'ëª¨ë¸ ì—†ìŒ');
                });
        }

        function showJsonMessage(message, type = 'info') {
            jsonContent.innerHTML = '';
            const paragraph = document.createElement('p');
            paragraph.className = `json-message ${type}`;
            paragraph.textContent = message;
            jsonContent.appendChild(paragraph);
        }

        function createPrimitiveNode(value, path) {
            const valueNode = document.createElement('div');
            const dataType = value === null ? 'null' : typeof value;
            valueNode.className = `json-primitive type-${dataType}`;
            valueNode.dataset.path = path;
            valueNode.dataset.originalType = dataType;
            valueNode.title = 'ë”ë¸”í´ë¦­í•˜ì—¬ í¸ì§‘';

            if (value === null) {
                valueNode.textContent = 'null';
            } else {
                valueNode.textContent = String(value);
            }

            valueNode.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                if (valueNode.classList.contains('editing')) return;
                startEditing(valueNode, path, valueNode.dataset.originalType);
            });

            return valueNode;
        }

        function createArrayNode(arrayValue, path) {
            const wrapper = document.createElement('ul');
            wrapper.className = 'json-array';
            wrapper.dataset.path = path;

            if (arrayValue.length === 0) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'json-empty';
                emptyItem.textContent = 'ë¹„ì–´ ìˆëŠ” ë¦¬ìŠ¤íŠ¸';
                wrapper.appendChild(emptyItem);
                return wrapper;
            }

            arrayValue.forEach((item, index) => {
                const row = document.createElement('li');
                row.className = 'json-array-item';

                const childPath = path ? `${path}.${index}` : String(index);

                const valueContainer = document.createElement('div');
                valueContainer.className = 'json-item-value';
                valueContainer.appendChild(renderJsonValue(item, childPath));

                row.appendChild(valueContainer);
                wrapper.appendChild(row);
            });

            return wrapper;
        }

        function createObjectNode(objectValue, path) {
            const wrapper = document.createElement('div');
            wrapper.className = 'json-object';
            wrapper.dataset.path = path;

            const entries = Object.entries(objectValue);
            if (entries.length === 0) {
                const emptyNode = document.createElement('div');
                emptyNode.className = 'json-empty';
                emptyNode.textContent = 'ë¹„ì–´ ìˆëŠ” ê°ì²´';
                wrapper.appendChild(emptyNode);
                return wrapper;
            }

            entries.forEach(([key, value]) => {
                const row = document.createElement('div');
                row.className = 'json-field';

                const keyNode = document.createElement('div');
                keyNode.className = 'json-field-key';
                keyNode.dataset.path = path ? `${path}.${key}` : key;
                keyNode.textContent = key;

                const childPath = path ? `${path}.${key}` : key;
                const valueContainer = document.createElement('div');
                valueContainer.className = 'json-field-value';
                valueContainer.appendChild(renderJsonValue(value, childPath));

                row.appendChild(keyNode);
                row.appendChild(valueContainer);
                wrapper.appendChild(row);
            });

            return wrapper;
        }

        function renderJsonValue(value, path = '') {
            if (Array.isArray(value)) {
                return createArrayNode(value, path);
            }

            if (value !== null && typeof value === 'object') {
                return createObjectNode(value, path);
            }

            return createPrimitiveNode(value, path);
        }

        function renderJsonContent(value) {
            currentJsonData = value;
            jsonContent.innerHTML = '';
            const treeRoot = renderJsonValue(value, 'root');
            treeRoot.classList.add('json-root');
            jsonContent.appendChild(treeRoot);
        }

        // === JSON Editing Utilities ===

        function parsePath(pathStr) {
            const parts = pathStr.split('.');
            if (parts[0] === 'root') parts.shift();
            return parts.map(p => /^\d+$/.test(p) ? parseInt(p, 10) : p);
        }

        function setNestedValue(data, pathStr, newValue) {
            const parts = parsePath(pathStr);
            let current = data;
            for (let i = 0; i < parts.length - 1; i++) {
                current = current[parts[i]];
                if (current == null) return;
            }
            current[parts[parts.length - 1]] = newValue;
        }

        function parseEditedValue(text, originalType) {
            if (text === 'null') return null;
            if (originalType === 'number') {
                const num = Number(text);
                return isNaN(num) ? text : num;
            }
            if (originalType === 'boolean') {
                if (text.toLowerCase() === 'true') return true;
                if (text.toLowerCase() === 'false') return false;
                return text;
            }
            return text;
        }

        function startEditing(node, path, dataType) {
            const originalText = node.textContent;
            node.textContent = '';
            node.classList.add('editing');

            const input = document.createElement('textarea');
            input.className = 'json-edit-input';
            input.value = originalText === 'null' ? '' : originalText;
            node.appendChild(input);

            function autoResize() {
                input.style.height = 'auto';
                input.style.height = Math.max(24, input.scrollHeight) + 'px';
            }
            input.addEventListener('input', autoResize);
            requestAnimationFrame(() => {
                autoResize();
                input.focus();
                input.select();
            });

            let committed = false;

            function commitEdit() {
                if (committed) return;
                committed = true;

                const newText = input.value;
                const newValue = parseEditedValue(newText, dataType);
                const newType = newValue === null ? 'null' : typeof newValue;

                node.className = `json-primitive type-${newType}`;
                node.dataset.originalType = newType;
                node.classList.remove('editing');
                node.textContent = newValue === null ? 'null' : String(newValue);
                node.title = 'ë”ë¸”í´ë¦­í•˜ì—¬ í¸ì§‘';

                if (String(newValue) !== originalText) {
                    setNestedValue(currentJsonData, path, newValue);
                    node.classList.add('edited');
                    markDirty();
                }
            }

            function cancelEdit() {
                if (committed) return;
                committed = true;
                node.classList.remove('editing');
                node.textContent = originalText;
            }

            input.addEventListener('blur', () => commitEdit());
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    input.blur();
                }
            });
        }

        // === Save State Management ===

        function getLsKey() {
            return LS_PREFIX + (selectedFilename || '');
        }

        function saveToLocalStorage() {
            if (!selectedFilename || !currentJsonData) return;
            try {
                localStorage.setItem(getLsKey(), JSON.stringify(currentJsonData));
            } catch (e) {
                console.warn('localStorage ì €ì¥ ì‹¤íŒ¨:', e);
            }
        }

        function loadFromLocalStorage() {
            if (!selectedFilename) return null;
            try {
                const stored = localStorage.getItem(getLsKey());
                return stored ? JSON.parse(stored) : null;
            } catch {
                return null;
            }
        }

        function clearLocalStorage() {
            if (!selectedFilename) return;
            try {
                localStorage.removeItem(getLsKey());
            } catch {}
        }

        function markDirty() {
            isDirty = true;
            saveToLocalStorage();
            updateSaveIndicator();
        }

        function markClean() {
            isDirty = false;
            clearLocalStorage();
            updateSaveIndicator();
        }

        function updateSaveIndicator() {
            if (!selectedFilename || !currentJsonData) {
                saveIndicator.textContent = '';
                saveIndicator.className = 'save-indicator';
                return;
            }
            if (isDirty) {
                saveIndicator.textContent = 'â— ë¯¸ì €ì¥';
                saveIndicator.className = 'save-indicator unsaved';
            } else {
                saveIndicator.textContent = 'âœ“ ì €ì¥ë¨';
                saveIndicator.className = 'save-indicator saved';
            }
        }

        function startAutoSave() {
            stopAutoSave();
            autoSaveTimer = setInterval(() => {
                if (isDirty && selectedFilename && currentJsonData) {
                    saveToServer();
                }
            }, AUTO_SAVE_INTERVAL);
        }

        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }

        function saveToServer() {
            if (!selectedFilename || !currentJsonData) return;
            const filename = selectedFilename;
            const lsKey = getLsKey();

            fetch('/character-dictionary', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    epub_filename: filename,
                    content: currentJsonData
                })
            })
            .then(response => parseJsonResponse(response))
            .then(data => {
                if (data.status === 'success' && selectedFilename === filename) {
                    markClean();
                } else if (data.status === 'success') {
                    try { localStorage.removeItem(lsKey); } catch {}
                }
            })
            .catch(error => {
                console.error('ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
            });
        }

        function flushAndReset() {
            if (isDirty && currentJsonData && selectedFilename) {
                const body = JSON.stringify({
                    epub_filename: selectedFilename,
                    content: currentJsonData
                });
                const lsKey = getLsKey();
                fetch('/character-dictionary', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: body
                }).then(() => {
                    try { localStorage.removeItem(lsKey); } catch {}
                }).catch(() => {});
            }
            stopAutoSave();
            currentJsonData = null;
            isDirty = false;
            updateSaveIndicator();
        }

        async function parseJsonResponse(response) {
            const rawText = await response.text();

            if (!rawText) {
                throw new Error(`ë¹ˆ ì‘ë‹µì…ë‹ˆë‹¤. (HTTP ${response.status})`);
            }

            try {
                return JSON.parse(rawText);
            } catch {
                const preview = rawText.length > 200 ? `${rawText.slice(0, 200)}...` : rawText;
                throw new Error(`JSON ì‘ë‹µì´ ì•„ë‹™ë‹ˆë‹¤. (HTTP ${response.status}) ${preview}`);
            }
        }

        function renderTaskState(task) {
            const progressValue = Number.isFinite(task.progress) ? task.progress : 0;
            taskProgress.innerHTML = `<p class="json-message">ìƒíƒœ: ${task.status} / ì§„í–‰ë¥ : ${progressValue}%</p>`;

            if (Array.isArray(task.logs) && task.logs.length > 0) {
                taskLogs.textContent = task.logs.join('\n');
            } else {
                taskLogs.textContent = 'ë¡œê·¸ ì—†ìŒ';
            }
        }

        function stopTaskPolling() {
            if (taskPollTimer) {
                clearInterval(taskPollTimer);
                taskPollTimer = null;
            }
            activeTaskId = null;
        }

        function startTaskPolling(taskId, onSuccess) {
            stopTaskPolling();
            activeTaskId = taskId;

            const poll = () => {
                fetch(`/tasks/${encodeURIComponent(taskId)}`)
                    .then(response => parseJsonResponse(response))
                    .then(data => {
                        if (data.status !== 'success' || !data.task) {
                            showMessage('âŒ ì‘ì—… ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨', 'error');
                            stopTaskPolling();
                            return;
                        }

                        const task = data.task;
                        renderTaskState(task);

                        if (task.status === 'success') {
                            stopTaskPolling();
                            onSuccess(task);
                            return;
                        }

                        if (task.status === 'error') {
                            stopTaskPolling();
                            showMessage(`âŒ ${task.error ?? 'ì‘ì—… ì‹¤íŒ¨'}`, 'error');
                        }
                    })
                    .catch(error => {
                        showMessage(`âŒ ì‘ì—… ìƒíƒœ í†µì‹  ì—ëŸ¬: ${error}`, 'error');
                        stopTaskPolling();
                    });
            };

            poll();
            taskPollTimer = setInterval(poll, 1000);
        }

        // 1. ë°•ìŠ¤ í´ë¦­ ì‹œ ìˆ¨ê²¨ì§„ file-input ì‹¤í–‰
        dropZone.addEventListener('click', () => fileInput.click());

        // 2. ë¸Œë¼ìš°ì € ê¸°ë³¸ ë“œë˜ê·¸ ë™ì‘ ë§‰ê¸° (íŒŒì¼ì´ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë ¤ë²„ë¦¬ëŠ” ê²ƒ ë°©ì§€)
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        // 3. ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì‹œê°ì  í”¼ë“œë°± (ìƒ‰ìƒ ë³€ê²½)
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.add('hover'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.remove('hover'), false);
        });

        // 4. ë“œë¡­(Drop) ë˜ëŠ” íŒŒì¼ ì„ íƒ(Change) ì‹œ ì²˜ë¦¬
        dropZone.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        function handleFiles(files) {
            if (files.length === 0) return;
            const file = files[0];
            
            // EPUB í™•ì¥ì ê²€ì‚¬
            if (!file.name.toLowerCase().endsWith('.epub')) {
                showMessage("ì˜¤ë¥˜: EPUB íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.", "error");
                return;
            }

            uploadFile(file);
        }

        // 5. ì„œë²„ë¡œ íŒŒì¼ ì „ì†¡ (Fetch API)
        function uploadFile(file) {
            showMessage(`ì—…ë¡œë“œ ì¤‘: ${file.name}...`, "success");
            
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => parseJsonResponse(response))
            .then(data => {
                if (data.status === 'success') {
                    showMessage(`âœ… ${data.message} (${data.filename})`, "success");
                    refreshUploadedFiles();
                } else {
                    showMessage(`âŒ ì—…ë¡œë“œ ì‹¤íŒ¨`, "error");
                }
            })
            .catch(error => {
                showMessage(`âŒ í†µì‹  ì—ëŸ¬: ${error}`, "error");
            });
        }

        // ë©”ì‹œì§€ ë„ìš°ëŠ” ìœ í‹¸ í•¨ìˆ˜
        function showMessage(text, type) {
            resultMsg.textContent = text;
            resultMsg.className = type;
            resultMsg.style.display = 'block';
        }

        function refreshUploadedFiles() {
            fetch('/uploads')
                .then(response => parseJsonResponse(response))
                .then(data => {
                    if (data.status !== 'success') {
                        return;
                    }

                    uploadedFiles.innerHTML = '';

                    if (!data.files || data.files.length === 0) {
                        selectedFilename = null;
                        const li = document.createElement('li');
                        li.textContent = 'ì•„ì§ ì—…ë¡œë“œëœ EPUB íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.';
                        li.className = 'empty';
                        uploadedFiles.appendChild(li);
                        showJsonMessage('íŒŒì¼ì„ ì„ íƒí•˜ë©´ character_dictionary.json ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.');
                        return;
                    }

                    const previousSelectedFilename = selectedFilename;
                    selectedFilename = null;

                    data.files.forEach(fileItem => {
                        const isObjectItem = typeof fileItem === 'object' && fileItem !== null;
                        const filenameValue = isObjectItem ? fileItem.filename : fileItem;
                        const hasDictionary = isObjectItem ? !!fileItem.has_character_dictionary : true;

                        if (!filenameValue) {
                            return;
                        }

                        const li = document.createElement('li');
                        const fileItemElement = document.createElement('span');
                        fileItemElement.className = 'file-item';
                        fileItemElement.dataset.filename = filenameValue;
                        fileItemElement.dataset.hasDictionary = hasDictionary ? 'true' : 'false';
                        fileItemElement.textContent = filenameValue;

                        if (previousSelectedFilename === filenameValue) {
                            fileItemElement.classList.add('selected');
                            selectedFilename = filenameValue;
                        }

                        li.appendChild(fileItemElement);
                        uploadedFiles.appendChild(li);
                    });

                    if (!selectedFilename) {
                        showJsonMessage('íŒŒì¼ì„ ì„ íƒí•˜ë©´ character_dictionary.json ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.');
                    }
                })
                .catch(() => {
                    // ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ í™”ë©´ ìœ ì§€
                });
        }

        uploadedFiles.addEventListener('click', (e) => {
            const target = e.target;
            if (!(target instanceof Element)) {
                return;
            }

            const itemElement = target.closest('.file-item');
            if (!(itemElement instanceof HTMLElement)) {
                return;
            }

            const filename = itemElement.dataset.filename;
            if (!filename) {
                return;
            }

            if (selectedFilename === filename) {
                flushAndReset();
                itemElement.classList.remove('selected');
                selectedFilename = null;
                showJsonMessage('ì„ íƒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤. íŒŒì¼ì„ ì„ íƒí•˜ë©´ character_dictionary.json ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.');
                return;
            }

            flushAndReset();

            uploadedFiles.querySelectorAll('.file-item.selected').forEach((element) => {
                element.classList.remove('selected');
            });
            itemElement.classList.add('selected');
            selectedFilename = filename;

            const hasDictionary = itemElement.dataset.hasDictionary === 'true';
            if (!hasDictionary) {
                showJsonMessage('ì´ íŒŒì¼ì—ëŠ” character_dictionary.jsonì´ ì—†ìŠµë‹ˆë‹¤.', 'warn');
                return;
            }

            showJsonMessage('JSONì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

            fetch(`/character-dictionary?epub_filename=${encodeURIComponent(filename)}`)
                .then(response => parseJsonResponse(response))
                .then(data => {
                    if (selectedFilename !== filename) {
                        return;
                    }

                    if (data.status !== 'success') {
                        showJsonMessage(`ì˜¤ë¥˜: ${data.message ?? 'JSONì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.'}`, 'error');
                        return;
                    }

                    const cached = loadFromLocalStorage();
                    if (cached) {
                        renderJsonContent(cached);
                        isDirty = true;
                        updateSaveIndicator();
                    } else {
                        renderJsonContent(data.content);
                        isDirty = false;
                        updateSaveIndicator();
                    }
                    startAutoSave();
                })
                .catch((error) => {
                    if (selectedFilename !== filename) {
                        return;
                    }
                    showJsonMessage(`í†µì‹  ì˜¤ë¥˜: ${error}`, 'error');
                });
        });

        dictProviderSelect.addEventListener('change', () => {
            loadModels(dictProviderSelect.value, dictModelSelect);
        });

        translateProviderSelect.addEventListener('change', () => {
            loadModels(translateProviderSelect.value, translateModelSelect);
        });

        dictGenerateBtn.addEventListener('click', () => {
            if (!selectedFilename) {
                showMessage('ë¨¼ì € EPUB íŒŒì¼ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                return;
            }

            if (!dictProviderSelect.value || !dictModelSelect.value) {
                showMessage('ìºë¦­í„° ì‚¬ì „ ìƒì„±ìš© Provider/Modelì„ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                return;
            }

            showMessage('ìºë¦­í„° ì‚¬ì „ ìƒì„± ì¤‘...', 'success');
            taskProgress.innerHTML = '<p class="json-message">ìƒíƒœ: queued / ì§„í–‰ë¥ : 0%</p>';
            taskLogs.textContent = 'ë¡œê·¸ ìˆ˜ì§‘ ì‹œì‘...';

            fetch('/tasks/character-dictionary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    epub_filename: selectedFilename,
                    provider: dictProviderSelect.value,
                    model: dictModelSelect.value,
                    save_to_file: true
                })
            })
            .then(response => parseJsonResponse(response))
            .then(data => {
                if (data.status !== 'success') {
                    showMessage(`âŒ ${data.message ?? 'ìºë¦­í„° ì‚¬ì „ ìƒì„± ì‹¤íŒ¨'}`, 'error');
                    return;
                }

                startTaskPolling(data.task_id, () => {
                    showMessage('âœ… ìºë¦­í„° ì‚¬ì „ ìƒì„± ì™„ë£Œ', 'success');
                    refreshUploadedFiles();

                    fetch(`/character-dictionary?epub_filename=${encodeURIComponent(selectedFilename)}`)
                        .then(response => parseJsonResponse(response))
                        .then(dictData => {
                            if (dictData.status !== 'success') {
                                showJsonMessage(`ì˜¤ë¥˜: ${dictData.message ?? 'JSONì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.'}`, 'error');
                                return;
                            }
                            renderJsonContent(dictData.content);
                            clearLocalStorage();
                            isDirty = false;
                            updateSaveIndicator();
                            startAutoSave();
                        })
                        .catch((error) => {
                            showJsonMessage(`í†µì‹  ì˜¤ë¥˜: ${error}`, 'error');
                        });
                });
            })
            .catch(error => {
                showMessage(`âŒ í†µì‹  ì—ëŸ¬: ${error}`, 'error');
            });
        });

        translateStartBtn.addEventListener('click', () => {
            if (!selectedFilename) {
                showMessage('ë¨¼ì € EPUB íŒŒì¼ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                return;
            }

            if (!translateProviderSelect.value || !translateModelSelect.value) {
                showMessage('ë²ˆì—­ìš© Provider/Modelì„ ì„ íƒí•´ ì£¼ì„¸ìš”.', 'error');
                return;
            }

            showMessage('ë²ˆì—­ ì‘ì—… ì‹œì‘...', 'success');
            taskProgress.innerHTML = '<p class="json-message">ìƒíƒœ: queued / ì§„í–‰ë¥ : 0%</p>';
            taskLogs.textContent = 'ë¡œê·¸ ìˆ˜ì§‘ ì‹œì‘...';

            fetch('/tasks/translation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    epub_filename: selectedFilename,
                    provider: translateProviderSelect.value,
                    model: translateModelSelect.value,
                    target_lang: 'ko',
                    max_chars: 8000,
                    max_workers: 10
                })
            })
            .then(response => parseJsonResponse(response))
            .then(data => {
                if (data.status !== 'success') {
                    showMessage(`âŒ ${data.message ?? 'ë²ˆì—­ ì‹¤íŒ¨'}`, 'error');
                    return;
                }

                startTaskPolling(data.task_id, (task) => {
                    const outputName = task?.result?.output_epub_filename ?? 'ì¶œë ¥ íŒŒì¼';
                    showMessage(`âœ… ë²ˆì—­ ì™„ë£Œ (${outputName})`, 'success');
                    refreshUploadedFiles();
                });
            })
            .catch(error => {
                showMessage(`âŒ í†µì‹  ì—ëŸ¬: ${error}`, 'error');
            });
        });

        // Ctrl+S manual save
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                if (isDirty) saveToServer();
            }
        });

        // Warn before page unload if unsaved
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
            }
        });

        loadProviderAndModels();
        refreshUploadedFiles();
    </script>
</body>
</html>